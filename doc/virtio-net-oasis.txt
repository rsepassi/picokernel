virtio-net
5.1.6 Device Operation

Packets are transmitted by placing them in the transmitq1…transmitqN, and buffers for incoming packets are placed in the receiveq1…receiveqN. In each case, the packet itself is preceded by a header:
struct virtio_net_hdr { 
#define VIRTIO_NET_HDR_F_NEEDS_CSUM    1 
#define VIRTIO_NET_HDR_F_DATA_VALID    2 
#define VIRTIO_NET_HDR_F_RSC_INFO      4 
        u8 flags; 
#define VIRTIO_NET_HDR_GSO_NONE        0 
#define VIRTIO_NET_HDR_GSO_TCPV4       1 
#define VIRTIO_NET_HDR_GSO_UDP         3 
#define VIRTIO_NET_HDR_GSO_TCPV6       4 
#define VIRTIO_NET_HDR_GSO_UDP_L4      5 
#define VIRTIO_NET_HDR_GSO_ECN      0x80 
        u8 gso_type; 
        le16 hdr_len; 
        le16 gso_size; 
        le16 csum_start; 
        le16 csum_offset; 
        le16 num_buffers; 
        le32 hash_value;        (Only if VIRTIO_NET_F_HASH_REPORT negotiated) 
        le16 hash_report;       (Only if VIRTIO_NET_F_HASH_REPORT negotiated) 
        le16 padding_reserved;  (Only if VIRTIO_NET_F_HASH_REPORT negotiated) 
};
The controlq is used to control various device features described further in section 5.1.6.5.
5.1.6.1 Legacy Interface: Device Operation

When using the legacy interface, transitional devices and drivers MUST format the fields in struct virtio_net_hdr according to the native endian of the guest rather than (necessarily when not using the legacy interface) little-endian.
The legacy driver only presented num_buffers in the struct virtio_net_hdr when VIRTIO_NET_F_MRG_RXBUF was negotiated; without that feature the structure was 2 bytes shorter.
When using the legacy interface, the driver SHOULD ignore the used length for the transmit queues and the controlq queue. Note: Historically, some devices put the total descriptor length there, even though no data was actually written.
5.1.6.2 Packet Transmission

Transmitting a single packet is simple, but varies depending on the different features the driver negotiated.
1.
The driver can send a completely checksummed packet. In this case, flags will be zero, and gso_type will be VIRTIO_NET_HDR_GSO_NONE.
2.
If the driver negotiated VIRTIO_NET_F_CSUM, it can skip checksumming the packet:
flags has the VIRTIO_NET_HDR_F_NEEDS_CSUM set,
csum_start is set to the offset within the packet to begin checksumming, and
csum_offset indicates how many bytes after the csum_start the new (16 bit ones’ complement) checksum is placed by the device.
The TCP checksum field in the packet is set to the sum of the TCP pseudo header, so that replacing it by the ones’ complement checksum of the TCP header and body will give the correct result.
Note: For example, consider a partially checksummed TCP (IPv4) packet. It will have a 14 byte ethernet header and 20 byte IP header followed by the TCP header (with the TCP checksum field 16 bytes into that header). csum_start will be 14+20 = 34 (the TCP checksum includes the header), and csum_offset will be 16.
3.
If the driver negotiated VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO, and the packet requires TCP segmentation, UDP segmentation or fragmentation, then gso_type is set to VIRTIO_NET_HDR_GSO_TCPV4, TCPV6, UDP_L4 or UDP. (Otherwise, it is set to VIRTIO_NET_HDR_GSO_NONE). In this case, packets larger than 1514 bytes can be transmitted: the metadata indicates how to replicate the packet header to cut it into smaller packets. The other gso fields are set:
If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated, hdr_len indicates the header length that needs to be replicated for each packet. It’s the number of bytes from the beginning of the packet to the beginning of the transport payload. Otherwise, if the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated, hdr_len is a hint to the device as to how much of the header needs to be kept to copy into each packet, usually set to the length of the headers, including the transport header10. Note: Some devices benefit from knowledge of the exact header length.
gso_size is the maximum size of each packet beyond that header (ie. MSS).
If the driver negotiated the VIRTIO_NET_F_HOST_ECN feature, the VIRTIO_NET_HDR_GSO_ECN bit in gso_type indicates that the TCP packet has the ECN bit set11.
4.
num_buffers is set to zero. This field is unused on transmitted packets.
5.
The header and packet are added as one output descriptor to the transmitq, and the device is notified of the new entry (see 5.1.5 Device Initialization).
5.1.6.2.1 Driver Requirements: Packet Transmission

The driver MUST set num_buffers to zero.
If VIRTIO_NET_F_CSUM is not negotiated, the driver MUST set flags to zero and SHOULD supply a fully checksummed packet to the device.
If VIRTIO_NET_F_HOST_TSO4 is negotiated, the driver MAY set gso_type to VIRTIO_NET_HDR_GSO_TCPV4 to request TCPv4 segmentation, otherwise the driver MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_TCPV4.
If VIRTIO_NET_F_HOST_TSO6 is negotiated, the driver MAY set gso_type to VIRTIO_NET_HDR_GSO_TCPV6 to request TCPv6 segmentation, otherwise the driver MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_TCPV6.
If VIRTIO_NET_F_HOST_UFO is negotiated, the driver MAY set gso_type to VIRTIO_NET_HDR_GSO_UDP to request UDP fragmentation, otherwise the driver MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_UDP.
If VIRTIO_NET_F_HOST_USO is negotiated, the driver MAY set gso_type to VIRTIO_NET_HDR_GSO_UDP_L4 to request UDP segmentation, otherwise the driver MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_UDP_L4.
The driver SHOULD NOT send to the device TCP packets requiring segmentation offload which have the Explicit Congestion Notification bit set, unless the VIRTIO_NET_F_HOST_ECN feature is negotiated, in which case the driver MUST set the VIRTIO_NET_HDR_GSO_ECN bit in gso_type.
If the VIRTIO_NET_F_CSUM feature has been negotiated, the driver MAY set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags, if so:
1.
the driver MUST validate the packet checksum at offset csum_offset from csum_start as well as all preceding offsets;
2.
the driver MUST set the packet checksum stored in the buffer to the TCP/UDP pseudo header;
3.
the driver MUST set csum_start and csum_offset such that calculating a ones’ complement checksum from csum_start up until the end of the packet and storing the result at offset csum_offset from csum_start will result in a fully checksummed packet;
If none of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have been negotiated, the driver MUST set gso_type to VIRTIO_NET_HDR_GSO_NONE.
If gso_type differs from VIRTIO_NET_HDR_GSO_NONE, then the driver MUST also set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags and MUST set gso_size to indicate the desired MSS.
If one of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have been negotiated:
If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated, and gso_type differs from VIRTIO_NET_HDR_GSO_NONE, the driver MUST set hdr_len to a value equal to the length of the headers, including the transport header.
If the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated, or gso_type is VIRTIO_NET_HDR_GSO_NONE, the driver SHOULD set hdr_len to a value not less than the length of the headers, including the transport header.
The driver SHOULD accept the VIRTIO_NET_F_GUEST_HDRLEN feature if it has been offered, and if it’s able to provide the exact header length.
The driver MUST NOT set the VIRTIO_NET_HDR_F_DATA_VALID and VIRTIO_NET_HDR_F_RSC_INFO bits in flags.
5.1.6.2.2 Device Requirements: Packet Transmission

The device MUST ignore flag bits that it does not recognize.
If VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags is not set, the device MUST NOT use the csum_start and csum_offset.
If one of the VIRTIO_NET_F_HOST_TSO4, TSO6, USO or UFO options have been negotiated:
If the VIRTIO_NET_F_GUEST_HDRLEN feature has been negotiated, and gso_type differs from VIRTIO_NET_HDR_GSO_NONE, the device MAY use hdr_len as the transport header size. Note: Caution should be taken by the implementation so as to prevent a malicious driver from attacking the device by setting an incorrect hdr_len.
If the VIRTIO_NET_F_GUEST_HDRLEN feature has not been negotiated, or gso_type is VIRTIO_NET_HDR_GSO_NONE, the device MAY use hdr_len only as a hint about the transport header size. The device MUST NOT rely on hdr_len to be correct. Note: This is due to various bugs in implementations.
If VIRTIO_NET_HDR_F_NEEDS_CSUM is not set, the device MUST NOT rely on the packet checksum being correct.
5.1.6.2.3 Packet Transmission Interrupt

Often a driver will suppress transmission virtqueue interrupts and check for used packets in the transmit path of following packets.
The normal behavior in this interrupt handler is to retrieve used buffers from the virtqueue and free the corresponding headers and packets.
5.1.6.3 Setting Up Receive Buffers

It is generally a good idea to keep the receive virtqueue as fully populated as possible: if it runs out, network performance will suffer.
If the VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6, VIRTIO_NET_F_GUEST_UFO, VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6 features are used, the maximum incoming packet will be to 65550 bytes long (the maximum size of a TCP or UDP packet, plus the 14 byte ethernet header), otherwise 1514 bytes. The 12-byte struct virtio_net_hdr is prepended to this, making for 65562 or 1526 bytes.
5.1.6.3.1 Driver Requirements: Setting Up Receive Buffers

If VIRTIO_NET_F_MRG_RXBUF is not negotiated:
If VIRTIO_NET_F_GUEST_TSO4, VIRTIO_NET_F_GUEST_TSO6, VIRTIO_NET_F_GUEST_UFO, VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6 are negotiated, the driver SHOULD populate the receive queue(s) with buffers of at least 65562 bytes.
Otherwise, the driver SHOULD populate the receive queue(s) with buffers of at least 1526 bytes.
If VIRTIO_NET_F_MRG_RXBUF is negotiated, each buffer MUST be at least the size of the struct virtio_net_hdr.
Note: Obviously each buffer can be split across multiple descriptor elements.
If VIRTIO_NET_F_MQ is negotiated, each of receiveq1…receiveqN that will be used SHOULD be populated with receive buffers.
5.1.6.3.2 Device Requirements: Setting Up Receive Buffers

The device MUST set num_buffers to the number of descriptors used to hold the incoming packet.
The device MUST use only a single descriptor if VIRTIO_NET_F_MRG_RXBUF was not negotiated. Note: This means that num_buffers will always be 1 if VIRTIO_NET_F_MRG_RXBUF is not negotiated.
5.1.6.4 Processing of Incoming Packets

When a packet is copied into a buffer in the receiveq, the optimal path is to disable further used buffer notifications for the receiveq and process packets until no more are found, then re-enable them.
Processing incoming packets involves:
1.
num_buffers indicates how many descriptors this packet is spread over (including this one): this will always be 1 if VIRTIO_NET_F_MRG_RXBUF was not negotiated. This allows receipt of large packets without having to allocate large buffers: a packet that does not fit in a single buffer can flow over to the next buffer, and so on. In this case, there will be at least num_buffers used buffers in the virtqueue, and the device chains them together to form a single packet in a way similar to how it would store it in a single buffer spread over multiple descriptors. The other buffers will not begin with a struct virtio_net_hdr.
2.
If num_buffers is one, then the entire packet will be contained within this buffer, immediately following the struct virtio_net_hdr.
3.
If the VIRTIO_NET_F_GUEST_CSUM feature was negotiated, the VIRTIO_NET_HDR_F_DATA_VALID bit in flags can be set: if so, device has validated the packet checksum. In case of multiple encapsulated protocols, one level of checksums has been validated.
Additionally, VIRTIO_NET_F_GUEST_CSUM, TSO4, TSO6, UDP and ECN features enable receive checksum, large receive offload and ECN support which are the input equivalents of the transmit checksum, transmit segmentation offloading and ECN features, as described in 5.1.6.2:
1.
If the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options were negotiated, then gso_type MAY be something other than VIRTIO_NET_HDR_GSO_NONE, and gso_size field indicates the desired MSS (see Packet Transmission point 2).
2.
If the VIRTIO_NET_F_RSC_EXT option was negotiated (this implies one of VIRTIO_NET_F_GUEST_TSO4, TSO6), the device processes also duplicated ACK segments, reports number of coalesced TCP segments in csum_start field and number of duplicated ACK segments in csum_offset field and sets bit VIRTIO_NET_HDR_F_RSC_INFO in flags.
3.
If the VIRTIO_NET_F_GUEST_CSUM feature was negotiated, the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags can be set: if so, the packet checksum at offset csum_offset from csum_start and any preceding checksums have been validated. The checksum on the packet is incomplete and if bit VIRTIO_NET_HDR_F_RSC_INFO is not set in flags, then csum_start and csum_offset indicate how to calculate it (see Packet Transmission point 1).
If applicable, the device calculates per-packet hash for incoming packets as defined in 5.1.6.4.3.
If applicable, the device reports hash information for incoming packets as defined in 5.1.6.4.5.
5.1.6.4.1 Device Requirements: Processing of Incoming Packets

If VIRTIO_NET_F_MRG_RXBUF has not been negotiated, the device MUST set num_buffers to 1.
If VIRTIO_NET_F_MRG_RXBUF has been negotiated, the device MUST set num_buffers to indicate the number of buffers the packet (including the header) is spread over.
If a receive packet is spread over multiple buffers, the device MUST use all buffers but the last (i.e. the first num_buffers - 1 buffers) completely up to the full length of each buffer supplied by the driver.
The device MUST use all buffers used by a single receive packet together, such that at least num_buffers are observed by driver as used.
If VIRTIO_NET_F_GUEST_CSUM is not negotiated, the device MUST set flags to zero and SHOULD supply a fully checksummed packet to the driver.
If VIRTIO_NET_F_GUEST_TSO4 is not negotiated, the device MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_TCPV4.
If VIRTIO_NET_F_GUEST_UDP is not negotiated, the device MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_UDP.
If VIRTIO_NET_F_GUEST_TSO6 is not negotiated, the device MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_TCPV6.
If none of VIRTIO_NET_F_GUEST_USO4 or VIRTIO_NET_F_GUEST_USO6 have been negotiated, the device MUST NOT set gso_type to VIRTIO_NET_HDR_GSO_UDP_L4.
The device SHOULD NOT send to the driver TCP packets requiring segmentation offload which have the Explicit Congestion Notification bit set, unless the VIRTIO_NET_F_GUEST_ECN feature is negotiated, in which case the device MUST set the VIRTIO_NET_HDR_GSO_ECN bit in gso_type.
If the VIRTIO_NET_F_GUEST_CSUM feature has been negotiated, the device MAY set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags, if so:
1.
the device MUST validate the packet checksum at offset csum_offset from csum_start as well as all preceding offsets;
2.
the device MUST set the packet checksum stored in the receive buffer to the TCP/UDP pseudo header;
3.
the device MUST set csum_start and csum_offset such that calculating a ones’ complement checksum from csum_start up until the end of the packet and storing the result at offset csum_offset from csum_start will result in a fully checksummed packet;
If none of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have been negotiated, the device MUST set gso_type to VIRTIO_NET_HDR_GSO_NONE.
If gso_type differs from VIRTIO_NET_HDR_GSO_NONE, then the device MUST also set the VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags MUST set gso_size to indicate the desired MSS. If VIRTIO_NET_F_RSC_EXT was negotiated, the device MUST also set VIRTIO_NET_HDR_F_RSC_INFO bit in flags, set csum_start to number of coalesced TCP segments and set csum_offset to number of received duplicated ACK segments.
If VIRTIO_NET_F_RSC_EXT was not negotiated, the device MUST not set VIRTIO_NET_HDR_F_RSC_INFO bit in flags.
If one of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have been negotiated, the device SHOULD set hdr_len to a value not less than the length of the headers, including the transport header.
If the VIRTIO_NET_F_GUEST_CSUM feature has been negotiated, the device MAY set the VIRTIO_NET_HDR_F_DATA_VALID bit in flags, if so, the device MUST validate the packet checksum (in case of multiple encapsulated protocols, one level of checksums is validated).
5.1.6.4.2 Driver Requirements: Processing of Incoming Packets

The driver MUST ignore flag bits that it does not recognize.
If VIRTIO_NET_HDR_F_NEEDS_CSUM bit in flags is not set or if VIRTIO_NET_HDR_F_RSC_INFO bit flags is set, the driver MUST NOT use the csum_start and csum_offset.
If one of the VIRTIO_NET_F_GUEST_TSO4, TSO6, UFO, USO4 or USO6 options have been negotiated, the driver MAY use hdr_len only as a hint about the transport header size. The driver MUST NOT rely on hdr_len to be correct. Note: This is due to various bugs in implementations.
If neither VIRTIO_NET_HDR_F_NEEDS_CSUM nor VIRTIO_NET_HDR_F_DATA_VALID is set, the driver MUST NOT rely on the packet checksum being correct.
5.1.6.4.3 Hash calculation for incoming packets

A device attempts to calculate a per-packet hash in the following cases:
The feature VIRTIO_NET_F_RSS was negotiated. The device uses the hash to determine the receive virtqueue to place incoming packets.
The feature VIRTIO_NET_F_HASH_REPORT was negotiated. The device reports the hash value and the hash type with the packet.
If the feature VIRTIO_NET_F_RSS was negotiated:
The device uses hash_types of the virtio_net_rss_config structure as ’Enabled hash types’ bitmask.
If additionally the feature VIRTIO_NET_F_HASH_TUNNEL was negotiated, the device uses enabled_tunnel_types of the virtnet_hash_tunnel structure as ’Encapsulation types enabled for inner header hash’ bitmask.
The device uses a key as defined in hash_key_data and hash_key_length of the virtio_net_rss_config structure (see 5.1.6.5.7.1).
If the feature VIRTIO_NET_F_RSS was not negotiated:
The device uses hash_types of the virtio_net_hash_config structure as ’Enabled hash types’ bitmask.
If additionally the feature VIRTIO_NET_F_HASH_TUNNEL was negotiated, the device uses enabled_tunnel_types of the virtnet_hash_tunnel structure as ’Encapsulation types enabled for inner header hash’ bitmask.
The device uses a key as defined in hash_key_data and hash_key_length of the virtio_net_hash_config structure (see 5.1.6.5.6.4).
Note that if the device offers VIRTIO_NET_F_HASH_REPORT, even if it supports only one pair of virtqueues, it MUST support at least one of commands of VIRTIO_NET_CTRL_MQ class to configure reported hash parameters:
If the device offers VIRTIO_NET_F_RSS, it MUST support VIRTIO_NET_CTRL_MQ_RSS_CONFIG command per 5.1.6.5.7.1.
Otherwise the device MUST support VIRTIO_NET_CTRL_MQ_HASH_CONFIG command per 5.1.6.5.6.4.
The per-packet hash calculation can depend on the IP packet type. See [IP], [UDP] and [TCP].
5.1.6.4.3.1 Supported/enabled hash types

Hash types applicable for IPv4 packets:
#define VIRTIO_NET_HASH_TYPE_IPv4              (1 << 0) 
#define VIRTIO_NET_HASH_TYPE_TCPv4             (1 << 1) 
#define VIRTIO_NET_HASH_TYPE_UDPv4             (1 << 2)
Hash types applicable for IPv6 packets without extension headers
#define VIRTIO_NET_HASH_TYPE_IPv6              (1 << 3) 
#define VIRTIO_NET_HASH_TYPE_TCPv6             (1 << 4) 
#define VIRTIO_NET_HASH_TYPE_UDPv6             (1 << 5)
Hash types applicable for IPv6 packets with extension headers
#define VIRTIO_NET_HASH_TYPE_IP_EX             (1 << 6) 
#define VIRTIO_NET_HASH_TYPE_TCP_EX            (1 << 7) 
#define VIRTIO_NET_HASH_TYPE_UDP_EX            (1 << 8)
5.1.6.4.3.2 IPv4 packets

The device calculates the hash on IPv4 packets according to ’Enabled hash types’ bitmask as follows:
If VIRTIO_NET_HASH_TYPE_TCPv4 is set and the packet has a TCP header, the hash is calculated over the following fields:
Source IP address
Destination IP address
Source TCP port
Destination TCP port
Else if VIRTIO_NET_HASH_TYPE_UDPv4 is set and the packet has a UDP header, the hash is calculated over the following fields:
Source IP address
Destination IP address
Source UDP port
Destination UDP port
Else if VIRTIO_NET_HASH_TYPE_IPv4 is set, the hash is calculated over the following fields:
Source IP address
Destination IP address
Else the device does not calculate the hash
5.1.6.4.3.3 IPv6 packets without extension header

The device calculates the hash on IPv6 packets without extension headers according to ’Enabled hash types’ bitmask as follows:
If VIRTIO_NET_HASH_TYPE_TCPv6 is set and the packet has a TCPv6 header, the hash is calculated over the following fields:
Source IPv6 address
Destination IPv6 address
Source TCP port
Destination TCP port
Else if VIRTIO_NET_HASH_TYPE_UDPv6 is set and the packet has a UDPv6 header, the hash is calculated over the following fields:
Source IPv6 address
Destination IPv6 address
Source UDP port
Destination UDP port
Else if VIRTIO_NET_HASH_TYPE_IPv6 is set, the hash is calculated over the following fields:
Source IPv6 address
Destination IPv6 address
Else the device does not calculate the hash
5.1.6.4.3.4 IPv6 packets with extension header

The device calculates the hash on IPv6 packets with extension headers according to ’Enabled hash types’ bitmask as follows:
If VIRTIO_NET_HASH_TYPE_TCP_EX is set and the packet has a TCPv6 header, the hash is calculated over the following fields:
Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
Source TCP port
Destination TCP port
Else if VIRTIO_NET_HASH_TYPE_UDP_EX is set and the packet has a UDPv6 header, the hash is calculated over the following fields:
Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
Source UDP port
Destination UDP port
Else if VIRTIO_NET_HASH_TYPE_IP_EX is set, the hash is calculated over the following fields:
Home address from the home address option in the IPv6 destination options header. If the extension header is not present, use the Source IPv6 address.
IPv6 address that is contained in the Routing-Header-Type-2 from the associated extension header. If the extension header is not present, use the Destination IPv6 address.
Else skip IPv6 extension headers and calculate the hash as defined for an IPv6 packet without extension headers (see 5.1.6.4.3.3).
5.1.6.4.4 Inner Header Hash

If VIRTIO_NET_F_HASH_TUNNEL has been negotiated, the driver can send the command VIRTIO_NET_CTRL_HASH_TUNNEL_SET to configure the calculation of the inner header hash.
struct virtnet_hash_tunnel { 
    le32 enabled_tunnel_types; 
}; 
 
#define VIRTIO_NET_CTRL_HASH_TUNNEL 7 
 #define VIRTIO_NET_CTRL_HASH_TUNNEL_SET 0
Field enabled_tunnel_types contains the bitmask of encapsulation types enabled for inner header hash. See 5.1.6.4.4.2.
The class VIRTIO_NET_CTRL_HASH_TUNNEL has one command: VIRTIO_NET_CTRL_HASH_TUNNEL_SET sets enabled_tunnel_types for the device using the virtnet_hash_tunnel structure, which is read-only for the device.
Inner header hash is disabled by VIRTIO_NET_CTRL_HASH_TUNNEL_SET with enabled_tunnel_types set to 0.
Initially (before the driver sends any VIRTIO_NET_CTRL_HASH_TUNNEL_SET command) all encapsulation types are disabled for inner header hash.
5.1.6.4.4.1 Encapsulated packet

Multiple tunneling protocols allow encapsulating an inner, payload packet in an outer, encapsulated packet. The encapsulated packet thus contains an outer header and an inner header, and the device calculates the hash over either the inner header or the outer header.
If VIRTIO_NET_F_HASH_TUNNEL is negotiated and a received encapsulated packet’s outer header matches one of the encapsulation types enabled in enabled_tunnel_types, then the device uses the inner header for hash calculations (only a single level of encapsulation is currently supported).
If VIRTIO_NET_F_HASH_TUNNEL is negotiated and a received packet’s (outer) header does not match any encapsulation types enabled in enabled_tunnel_types, then the device uses the outer header for hash calculations.
5.1.6.4.4.2 Encapsulation types supported/enabled for inner header hash

Encapsulation types applicable for inner header hash:
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_2784    (1 << 0) /* [RFC2784] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_2890    (1 << 1) /* [RFC2890] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_7676    (1 << 2) /* [RFC7676] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GRE_UDP     (1 << 3) /* [GRE-in-UDP] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_VXLAN       (1 << 4) /* [VXLAN] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_VXLAN_GPE   (1 << 5) /* [VXLAN-GPE] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_GENEVE      (1 << 6) /* [GENEVE] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_IPIP        (1 << 7) /* [IPIP] */ 
#define VIRTIO_NET_HASH_TUNNEL_TYPE_NVGRE       (1 << 8) /* [NVGRE] */
5.1.6.4.4.3 Advice

Example uses of the inner header hash:
Legacy tunneling protocols, lacking the outer header entropy, can use RSS with the inner header hash to distribute flows with identical outer but different inner headers across various queues, improving performance.
Identify an inner flow distributed across multiple outer tunnels.
As using the inner header hash completely discards the outer header entropy, care must be taken if the inner header is controlled by an adversary, as the adversary can then intentionally create configurations with insufficient entropy.
Besides disabling the inner header hash, mitigations would depend on how the hash is used. When the hash use is limited to the RSS queue selection, the inner header hash may have quality of service (QoS) limitations.
5.1.6.4.4.4 Device Requirements: Inner Header Hash

If the (outer) header of the received packet does not match any encapsulation types enabled in enabled_tunnel_types, the device MUST calculate the hash on the outer header.
If the device receives any bits in enabled_tunnel_types which are not set in supported_tunnel_types, it SHOULD respond to the VIRTIO_NET_CTRL_HASH_TUNNEL_SET command with VIRTIO_NET_ERR.
If the driver sets enabled_tunnel_types to 0 through VIRTIO_NET_CTRL_HASH_TUNNEL_SET or upon the device reset, the device MUST disable the inner header hash for all encapsulation types.
5.1.6.4.4.5 Driver Requirements: Inner Header Hash

The driver MUST have negotiated the VIRTIO_NET_F_HASH_TUNNEL feature when issuing the VIRTIO_NET_CTRL_HASH_TUNNEL_SET command.
The driver MUST NOT set any bits in enabled_tunnel_types which are not set in supported_tunnel_types.
The driver MUST ignore bits in supported_tunnel_types which are not documented in this specification.
5.1.6.4.5 Hash reporting for incoming packets

If VIRTIO_NET_F_HASH_REPORT was negotiated and the device has calculated the hash for the packet, the device fills hash_report with the report type of calculated hash and hash_value with the value of calculated hash.
If VIRTIO_NET_F_HASH_REPORT was negotiated but due to any reason the hash was not calculated, the device sets hash_report to VIRTIO_NET_HASH_REPORT_NONE.
Possible values that the device can report in hash_report are defined below. They correspond to supported hash types defined in 5.1.6.4.3.1 as follows:
VIRTIO_NET_HASH_TYPE_XXX = 1 « (VIRTIO_NET_HASH_REPORT_XXX - 1)
#define VIRTIO_NET_HASH_REPORT_NONE            0 
#define VIRTIO_NET_HASH_REPORT_IPv4            1 
#define VIRTIO_NET_HASH_REPORT_TCPv4           2 
#define VIRTIO_NET_HASH_REPORT_UDPv4           3 
#define VIRTIO_NET_HASH_REPORT_IPv6            4 
#define VIRTIO_NET_HASH_REPORT_TCPv6           5 
#define VIRTIO_NET_HASH_REPORT_UDPv6           6 
#define VIRTIO_NET_HASH_REPORT_IPv6_EX         7 
#define VIRTIO_NET_HASH_REPORT_TCPv6_EX        8 
#define VIRTIO_NET_HASH_REPORT_UDPv6_EX        9
5.1.6.5 Control Virtqueue

The driver uses the control virtqueue (if VIRTIO_NET_F_CTRL_VQ is negotiated) to send commands to manipulate various features of the device which would not easily map into the configuration space.
All commands are of the following form:
struct virtio_net_ctrl { 
        u8 class; 
        u8 command; 
        u8 command-specific-data[]; 
        u8 ack; 
}; 
 
/* ack values */ 
#define VIRTIO_NET_OK     0 
#define VIRTIO_NET_ERR    1
The class, command and command-specific-data are set by the driver, and the device sets the ack byte. There is little it can do except issue a diagnostic if ack is not VIRTIO_NET_OK.
5.1.6.5.1 Packet Receive Filtering

If the VIRTIO_NET_F_CTRL_RX and VIRTIO_NET_F_CTRL_RX_EXTRA features are negotiated, the driver can send control commands for promiscuous mode, multicast, unicast and broadcast receiving. Note: In general, these commands are best-effort: unwanted packets could still arrive.
#define VIRTIO_NET_CTRL_RX    0 
 #define VIRTIO_NET_CTRL_RX_PROMISC      0 
 #define VIRTIO_NET_CTRL_RX_ALLMULTI     1 
 #define VIRTIO_NET_CTRL_RX_ALLUNI       2 
 #define VIRTIO_NET_CTRL_RX_NOMULTI      3 
 #define VIRTIO_NET_CTRL_RX_NOUNI        4 
 #define VIRTIO_NET_CTRL_RX_NOBCAST      5
5.1.6.5.1.1 Device Requirements: Packet Receive Filtering

If the VIRTIO_NET_F_CTRL_RX feature has been negotiated, the device MUST support the following VIRTIO_NET_CTRL_RX class commands:
VIRTIO_NET_CTRL_RX_PROMISC turns promiscuous mode on and off. The command-specific-data is one byte containing 0 (off) or 1 (on). If promiscuous mode is on, the device SHOULD receive all incoming packets. This SHOULD take effect even if one of the other modes set by a VIRTIO_NET_CTRL_RX class command is on.
VIRTIO_NET_CTRL_RX_ALLMULTI turns all-multicast receive on and off. The command-specific-data is one byte containing 0 (off) or 1 (on). When all-multicast receive is on the device SHOULD allow all incoming multicast packets.
If the VIRTIO_NET_F_CTRL_RX_EXTRA feature has been negotiated, the device MUST support the following VIRTIO_NET_CTRL_RX class commands:
VIRTIO_NET_CTRL_RX_ALLUNI turns all-unicast receive on and off. The command-specific-data is one byte containing 0 (off) or 1 (on). When all-unicast receive is on the device SHOULD allow all incoming unicast packets.
VIRTIO_NET_CTRL_RX_NOMULTI suppresses multicast receive. The command-specific-data is one byte containing 0 (multicast receive allowed) or 1 (multicast receive suppressed). When multicast receive is suppressed, the device SHOULD NOT send multicast packets to the driver. This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLMULTI is on. This filter SHOULD NOT apply to broadcast packets.
VIRTIO_NET_CTRL_RX_NOUNI suppresses unicast receive. The command-specific-data is one byte containing 0 (unicast receive allowed) or 1 (unicast receive suppressed). When unicast receive is suppressed, the device SHOULD NOT send unicast packets to the driver. This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLUNI is on.
VIRTIO_NET_CTRL_RX_NOBCAST suppresses broadcast receive. The command-specific-data is one byte containing 0 (broadcast receive allowed) or 1 (broadcast receive suppressed). When broadcast receive is suppressed, the device SHOULD NOT send broadcast packets to the driver. This SHOULD take effect even if VIRTIO_NET_CTRL_RX_ALLMULTI is on.
5.1.6.5.1.2 Driver Requirements: Packet Receive Filtering

If the VIRTIO_NET_F_CTRL_RX feature has not been negotiated, the driver MUST NOT issue commands VIRTIO_NET_CTRL_RX_PROMISC or VIRTIO_NET_CTRL_RX_ALLMULTI.
If the VIRTIO_NET_F_CTRL_RX_EXTRA feature has not been negotiated, the driver MUST NOT issue commands VIRTIO_NET_CTRL_RX_ALLUNI, VIRTIO_NET_CTRL_RX_NOMULTI, VIRTIO_NET_CTRL_RX_NOUNI or VIRTIO_NET_CTRL_RX_NOBCAST.
5.1.6.5.2 Setting MAC Address Filtering

If the VIRTIO_NET_F_CTRL_RX feature is negotiated, the driver can send control commands for MAC address filtering.
struct virtio_net_ctrl_mac { 
        le32 entries; 
        u8 macs[entries][6]; 
}; 
 
#define VIRTIO_NET_CTRL_MAC    1 
 #define VIRTIO_NET_CTRL_MAC_TABLE_SET        0 
 #define VIRTIO_NET_CTRL_MAC_ADDR_SET         1
The device can filter incoming packets by any number of destination MAC addresses12. This table is set using the class VIRTIO_NET_CTRL_MAC and the command VIRTIO_NET_CTRL_MAC_TABLE_SET. The command-specific-data is two variable length tables of 6-byte MAC addresses (as described in struct virtio_net_ctrl_mac). The first table contains unicast addresses, and the second contains multicast addresses.
The VIRTIO_NET_CTRL_MAC_ADDR_SET command is used to set the default MAC address which rx filtering accepts (and if VIRTIO_NET_F_MAC has been negotiated, this will be reflected in mac in config space).
The command-specific-data for VIRTIO_NET_CTRL_MAC_ADDR_SET is the 6-byte MAC address.
5.1.6.5.2.1 Device Requirements: Setting MAC Address Filtering

The device MUST have an empty MAC filtering table on reset.
The device MUST update the MAC filtering table before it consumes the VIRTIO_NET_CTRL_MAC_TABLE_SET command.
The device MUST update mac in config space before it consumes the VIRTIO_NET_CTRL_MAC_ADDR_SET command, if VIRTIO_NET_F_MAC has been negotiated.
The device SHOULD drop incoming packets which have a destination MAC which matches neither the mac (or that set with VIRTIO_NET_CTRL_MAC_ADDR_SET) nor the MAC filtering table.
5.1.6.5.2.2 Driver Requirements: Setting MAC Address Filtering

If VIRTIO_NET_F_CTRL_RX has not been negotiated, the driver MUST NOT issue VIRTIO_NET_CTRL_MAC class commands.
If VIRTIO_NET_F_CTRL_RX has been negotiated, the driver SHOULD issue VIRTIO_NET_CTRL_MAC_ADDR_SET to set the default mac if it is different from mac.
The driver MUST follow the VIRTIO_NET_CTRL_MAC_TABLE_SET command by a le32 number, followed by that number of non-multicast MAC addresses, followed by another le32 number, followed by that number of multicast addresses. Either number MAY be 0.
5.1.6.5.2.3 Legacy Interface: Setting MAC Address Filtering

When using the legacy interface, transitional devices and drivers MUST format entries in struct virtio_net_ctrl_mac according to the native endian of the guest rather than (necessarily when not using the legacy interface) little-endian.
Legacy drivers that didn’t negotiate VIRTIO_NET_F_CTRL_MAC_ADDR changed mac in config space when NIC is accepting incoming packets. These drivers always wrote the mac value from first to last byte, therefore after detecting such drivers, a transitional device MAY defer MAC update, or MAY defer processing incoming packets until driver writes the last byte of mac in the config space.
5.1.6.5.3 VLAN Filtering

If the driver negotiates the VIRTIO_NET_F_CTRL_VLAN feature, it can control a VLAN filter table in the device. The VLAN filter table applies only to VLAN tagged packets.
When VIRTIO_NET_F_CTRL_VLAN is negotiated, the device starts with an empty VLAN filter table. Note: Similar to the MAC address based filtering, the VLAN filtering is also best-effort: unwanted packets could still arrive.
#define VIRTIO_NET_CTRL_VLAN       2 
 #define VIRTIO_NET_CTRL_VLAN_ADD             0 
 #define VIRTIO_NET_CTRL_VLAN_DEL             1
Both the VIRTIO_NET_CTRL_VLAN_ADD and VIRTIO_NET_CTRL_VLAN_DEL command take a little-endian 16-bit VLAN id as the command-specific-data.
VIRTIO_NET_CTRL_VLAN_ADD command adds the specified VLAN to the VLAN filter table.
VIRTIO_NET_CTRL_VLAN_DEL command removes the specified VLAN from the VLAN filter table.
5.1.6.5.3.1 Device Requirements: VLAN Filtering

When VIRTIO_NET_F_CTRL_VLAN is not negotiated, the device MUST accept all VLAN tagged packets.
When VIRTIO_NET_F_CTRL_VLAN is negotiated, the device MUST accept all VLAN tagged packets whose VLAN tag is present in the VLAN filter table and SHOULD drop all VLAN tagged packets whose VLAN tag is absent in the VLAN filter table.
5.1.6.5.3.2 Legacy Interface: VLAN Filtering

When using the legacy interface, transitional devices and drivers MUST format the VLAN id according to the native endian of the guest rather than (necessarily when not using the legacy interface) little-endian.
5.1.6.5.4 Gratuitous Packet Sending

If the driver negotiates the VIRTIO_NET_F_GUEST_ANNOUNCE (depends on VIRTIO_NET_F_CTRL_VQ), the device can ask the driver to send gratuitous packets; this is usually done after the guest has been physically migrated, and needs to announce its presence on the new network links. (As hypervisor does not have the knowledge of guest network configuration (eg. tagged vlan) it is simplest to prod the guest in this way).
#define VIRTIO_NET_CTRL_ANNOUNCE       3 
 #define VIRTIO_NET_CTRL_ANNOUNCE_ACK             0
The driver checks VIRTIO_NET_S_ANNOUNCE bit in the device configuration status field when it notices the changes of device configuration. The command VIRTIO_NET_CTRL_ANNOUNCE_ACK is used to indicate that driver has received the notification and device clears the VIRTIO_NET_S_ANNOUNCE bit in status.
Processing this notification involves:
1.
Sending the gratuitous packets (eg. ARP) or marking there are pending gratuitous packets to be sent and letting deferred routine to send them.
2.
Sending VIRTIO_NET_CTRL_ANNOUNCE_ACK command through control vq.
5.1.6.5.4.1 Driver Requirements: Gratuitous Packet Sending

If the driver negotiates VIRTIO_NET_F_GUEST_ANNOUNCE, it SHOULD notify network peers of its new location after it sees the VIRTIO_NET_S_ANNOUNCE bit in status. The driver MUST send a command on the command queue with class VIRTIO_NET_CTRL_ANNOUNCE and command VIRTIO_NET_CTRL_ANNOUNCE_ACK.
5.1.6.5.4.2 Device Requirements: Gratuitous Packet Sending

If VIRTIO_NET_F_GUEST_ANNOUNCE is negotiated, the device MUST clear the VIRTIO_NET_S_ANNOUNCE bit in status upon receipt of a command buffer with class VIRTIO_NET_CTRL_ANNOUNCE and command VIRTIO_NET_CTRL_ANNOUNCE_ACK before marking the buffer as used.
5.1.6.5.5 Device operation in multiqueue mode

This specification defines the following modes that a device MAY implement for operation with multiple transmit/receive virtqueues:
Automatic receive steering as defined in 5.1.6.5.6. If a device supports this mode, it offers the VIRTIO_NET_F_MQ feature bit.
Receive-side scaling as defined in 5.1.6.5.7.3. If a device supports this mode, it offers the VIRTIO_NET_F_RSS feature bit.
A device MAY support one of these features or both. The driver MAY negotiate any set of these features that the device supports.
Multiqueue is disabled by default.
The driver enables multiqueue by sending a command using class VIRTIO_NET_CTRL_MQ. The command selects the mode of multiqueue operation, as follows:
#define VIRTIO_NET_CTRL_MQ    4 
 #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET        0 (for automatic receive steering) 
 #define VIRTIO_NET_CTRL_MQ_RSS_CONFIG          1 (for configurable receive steering) 
 #define VIRTIO_NET_CTRL_MQ_HASH_CONFIG         2 (for configurable hash calculation)
If more than one multiqueue mode is negotiated, the resulting device configuration is defined by the last command sent by the driver.
5.1.6.5.6 Automatic receive steering in multiqueue mode

If the driver negotiates the VIRTIO_NET_F_MQ feature bit (depends on VIRTIO_NET_F_CTRL_VQ), it MAY transmit outgoing packets on one of the multiple transmitq1…transmitqN and ask the device to queue incoming packets into one of the multiple receiveq1…receiveqN depending on the packet flow.
The driver enables multiqueue by sending the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command, specifying the number of the transmit and receive queues to be used up to max_virtqueue_pairs; subsequently, transmitq1…transmitqn and receiveq1…receiveqn where n=virtqueue_pairs MAY be used.
struct virtio_net_ctrl_mq_pairs_set { 
       le16 virtqueue_pairs; 
}; 
#define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN        1 
#define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX        0x8000
When multiqueue is enabled by VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command, the device MUST use automatic receive steering based on packet flow. Programming of the receive steering classificator is implicit. After the driver transmitted a packet of a flow on transmitqX, the device SHOULD cause incoming packets for that flow to be steered to receiveqX. For uni-directional protocols, or where no packets have been transmitted yet, the device MAY steer a packet to a random queue out of the specified receiveq1…receiveqn.
Multiqueue is disabled by VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET with virtqueue_pairs to 1 (this is the default) and waiting for the device to use the command buffer.
5.1.6.5.6.1 Driver Requirements: Automatic receive steering in multiqueue mode

The driver MUST configure the virtqueues before enabling them with the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command.
The driver MUST NOT request a virtqueue_pairs of 0 or greater than max_virtqueue_pairs in the device configuration space.
The driver MUST queue packets only on any transmitq1 before the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command.
The driver MUST NOT queue packets on transmit queues greater than virtqueue_pairs once it has placed the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command in the available ring.
5.1.6.5.6.2 Device Requirements: Automatic receive steering in multiqueue mode

After initialization of reset, the device MUST queue packets only on receiveq1.
The device MUST NOT queue packets on receive queues greater than virtqueue_pairs once it has placed the VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET command in a used buffer.
If the destination receive queue is being reset (See 2.6.1), the device SHOULD re-select another random queue. If all receive queues are being reset, the device MUST drop the packet.
5.1.6.5.6.3 Legacy Interface: Automatic receive steering in multiqueue mode

When using the legacy interface, transitional devices and drivers MUST format virtqueue_pairs according to the native endian of the guest rather than (necessarily when not using the legacy interface) little-endian.
5.1.6.5.6.4 Hash calculation

If VIRTIO_NET_F_HASH_REPORT was negotiated and the device uses automatic receive steering, the device MUST support a command to configure hash calculation parameters.
The driver provides parameters for hash calculation as follows:
class VIRTIO_NET_CTRL_MQ, command VIRTIO_NET_CTRL_MQ_HASH_CONFIG.
The command-specific-data has following format:
struct virtio_net_hash_config { 
    le32 hash_types; 
    le16 reserved[4]; 
    u8 hash_key_length; 
    u8 hash_key_data[hash_key_length]; 
};
Field hash_types contains a bitmask of allowed hash types as defined in 5.1.6.4.3.1. Initially the device has all hash types disabled and reports only VIRTIO_NET_HASH_REPORT_NONE.
Field reserved MUST contain zeroes. It is defined to make the structure to match the layout of virtio_net_rss_config structure, defined in 5.1.6.5.7.
Fields hash_key_length and hash_key_data define the key to be used in hash calculation.
5.1.6.5.7 Receive-side scaling (RSS)

A device offers the feature VIRTIO_NET_F_RSS if it supports RSS receive steering with Toeplitz hash calculation and configurable parameters.
A driver queries RSS capabilities of the device by reading device configuration as defined in 5.1.4
5.1.6.5.7.1 Setting RSS parameters

Driver sends a VIRTIO_NET_CTRL_MQ_RSS_CONFIG command using the following format for command-specific-data:
struct rss_rq_id { 
   le16 vq_index_1_16: 15; /* Bits 1 to 16 of the virtqueue index */ 
   le16 reserved: 1; /* Set to zero */ 
}; 
 
struct virtio_net_rss_config { 
    le32 hash_types; 
    le16 indirection_table_mask; 
    struct rss_rq_id unclassified_queue; 
    struct rss_rq_id indirection_table[indirection_table_length]; 
    le16 max_tx_vq; 
    u8 hash_key_length; 
    u8 hash_key_data[hash_key_length]; 
};
Field hash_types contains a bitmask of allowed hash types as defined in 5.1.6.4.3.1.
Field indirection_table_mask is a mask to be applied to the calculated hash to produce an index in the indirection_table array. Number of entries in indirection_table is (indirection_table_mask + 1).
rss_rq_id is a receive virtqueue id. vq_index_1_16 consists of bits 1 to 16 of a virtqueue index. For example, a vq_index_1_16 value of 3 corresponds to virtqueue index 6, which maps to receiveq4.
Field unclassified_queue specifies the receive virtqueue id in which to place unclassified packets.
Field indirection_table is an array of receive virtqueues ids.
A driver sets max_tx_vq to inform a device how many transmit virtqueues it may use (transmitq1…transmitq max_tx_vq).
Fields hash_key_length and hash_key_data define the key to be used in hash calculation.
5.1.6.5.7.2 Driver Requirements: Setting RSS parameters

A driver MUST NOT send the VIRTIO_NET_CTRL_MQ_RSS_CONFIG command if the feature VIRTIO_NET_F_RSS has not been negotiated.
A driver MUST fill the indirection_table array only with enabled receive virtqueues ids.
The number of entries in indirection_table (indirection_table_mask + 1) MUST be a power of two.
A driver MUST use indirection_table_mask values that are less than rss_max_indirection_table_length reported by a device.
A driver MUST NOT set any VIRTIO_NET_HASH_TYPE_ flags that are not supported by a device.
5.1.6.5.7.3 Device Requirements: RSS processing

The device MUST determine the destination queue for a network packet as follows:
Calculate the hash of the packet as defined in 5.1.6.4.3.
If the device did not calculate the hash for the specific packet, the device directs the packet to the receiveq specified by unclassified_queue of virtio_net_rss_config structure.
Apply indirection_table_mask to the calculated hash and use the result as the index in the indirection table to get the destination receive virtqueue id.
If the destination receive queue is being reset (See 2.6.1), the device MUST drop the packet.
5.1.6.5.8 Offloads State Configuration

If the VIRTIO_NET_F_CTRL_GUEST_OFFLOADS feature is negotiated, the driver can send control commands for dynamic offloads state configuration.
5.1.6.5.8.1 Setting Offloads State

To configure the offloads, the following layout structure and definitions are used:
le64 offloads; 
 
#define VIRTIO_NET_F_GUEST_CSUM       1 
#define VIRTIO_NET_F_GUEST_TSO4       7 
#define VIRTIO_NET_F_GUEST_TSO6       8 
#define VIRTIO_NET_F_GUEST_ECN        9 
#define VIRTIO_NET_F_GUEST_UFO        10 
#define VIRTIO_NET_F_GUEST_USO4       54 
#define VIRTIO_NET_F_GUEST_USO6       55 
 
#define VIRTIO_NET_CTRL_GUEST_OFFLOADS       5 
 #define VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET   0
The class VIRTIO_NET_CTRL_GUEST_OFFLOADS has one command: VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET applies the new offloads configuration.
le64 value passed as command data is a bitmask, bits set define offloads to be enabled, bits cleared - offloads to be disabled.
There is a corresponding device feature for each offload. Upon feature negotiation corresponding offload gets enabled to preserve backward compatibility.
5.1.6.5.8.2 Driver Requirements: Setting Offloads State

A driver MUST NOT enable an offload for which the appropriate feature has not been negotiated.
5.1.6.5.8.3 Legacy Interface: Setting Offloads State

When using the legacy interface, transitional devices and drivers MUST format offloads according to the native endian of the guest rather than (necessarily when not using the legacy interface) little-endian.
5.1.6.5.9 Notifications Coalescing

If the VIRTIO_NET_F_NOTF_COAL feature is negotiated, the driver can send commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET for notification coalescing.
If the VIRTIO_NET_F_VQ_NOTF_COAL feature is negotiated, the driver can send commands VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET for virtqueue notification coalescing.
struct virtio_net_ctrl_coal { 
    le32 max_packets; 
    le32 max_usecs; 
}; 
 
struct virtio_net_ctrl_coal_vq { 
    le16 vq_index; 
    le16 reserved; 
    struct virtio_net_ctrl_coal coal; 
}; 
 
#define VIRTIO_NET_CTRL_NOTF_COAL 6 
 #define VIRTIO_NET_CTRL_NOTF_COAL_TX_SET  0 
 #define VIRTIO_NET_CTRL_NOTF_COAL_RX_SET 1 
 #define VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET 2 
 #define VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET 3
Coalescing parameters:
vq_index: The virtqueue index of an enabled transmit or receive virtqueue.
max_usecs for RX: Maximum number of microseconds to delay a RX notification.
max_usecs for TX: Maximum number of microseconds to delay a TX notification.
max_packets for RX: Maximum number of packets to receive before a RX notification.
max_packets for TX: Maximum number of packets to send before a TX notification.
reserved is reserved and it is ignored by the device.
Read/Write attributes for coalescing parameters:
For commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET, the structure virtio_net_ctrl_coal is write-only for the driver.
For the command VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET, the structure virtio_net_ctrl_coal_vq is write-only for the driver.
For the command VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET, vq_index and reserved are write-only for the driver, and the structure virtio_net_ctrl_coal is read-only for the driver.
The class VIRTIO_NET_CTRL_NOTF_COAL has the following commands:
1.
VIRTIO_NET_CTRL_NOTF_COAL_TX_SET: use the structure virtio_net_ctrl_coal to set the max_usecs and max_packets parameters for all transmit virtqueues.
2.
VIRTIO_NET_CTRL_NOTF_COAL_RX_SET: use the structure virtio_net_ctrl_coal to set the max_usecs and max_packets parameters for all receive virtqueues.
3.
VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET: use the structure virtio_net_ctrl_coal_vq to set the max_usecs and max_packets parameters for an enabled transmit/receive virtqueue whose index is vq_index.
4.
VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET: use the structure virtio_net_ctrl_coal_vq to get the max_usecs and max_packets parameters for an enabled transmit/receive virtqueue whose index is vq_index.
The device may generate notifications more or less frequently than specified by set commands of the VIRTIO_NET_CTRL_NOTF_COAL class.
If coalescing parameters are being set, the device applies the last coalescing parameters set for a virtqueue, regardless of the command used to set the parameters. Use the following command sequence with two pairs of virtqueues as an example: Each of the following commands sets max_usecs and max_packets parameters for virtqueues.
Command1: VIRTIO_NET_CTRL_NOTF_COAL_RX_SET sets coalescing parameters for virtqueues having index 0 and index 2. Virtqueues having index 1 and index 3 retain their previous parameters.
Command2: VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET with vq_index = 0 sets coalescing parameters for virtqueue having index 0. Virtqueue having index 2 retains the parameters from command1.
Command3: VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET with vq_index = 0, the device responds with coalescing parameters of vq_index 0 set by command2.
Command4: VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET with vq_index = 1 sets coalescing parameters for virtqueue having index 1. Virtqueue having index 3 retains its previous parameters.
Command5: VIRTIO_NET_CTRL_NOTF_COAL_TX_SET sets coalescing parameters for virtqueues having index 1 and index 3, and overrides the parameters set by command4.
Command6: VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET with vq_index = 1, the device responds with coalescing parameters of index 1 set by command5.
5.1.6.5.9.1 Operation

The device sends a used buffer notification once the notification conditions are met and if the notifications are not suppressed as explained in 2.7.7.
When the device has non-zero max_usecs and non-zero max_packets, it starts counting microseconds and packets upon receiving/sending a packet. The device counts packets and microseconds for each receive virtqueue and transmit virtqueue separately. In this case, the notification conditions are met when max_usecs microseconds elapse, or upon sending/receiving max_packets packets, whichever happens first. Afterwards, the device waits for the next packet and starts counting packets and microseconds again.
When the device has max_usecs = 0 or max_packets = 0, the notification conditions are met after every packet received/sent.
5.1.6.5.9.2 RX Example

If, for example:
max_usecs = 10.
max_packets = 15.
then each receive virtqueue of a device will operate as follows:
The device will count packets received on each virtqueue until it accumulates 15, or until 10 microseconds elapsed since the first one was received.
If the notifications are not suppressed by the driver, the device will send an used buffer notification, otherwise, the device will not send an used buffer notification as long as the notifications are suppressed.
5.1.6.5.9.3 TX Example

If, for example:
max_usecs = 10.
max_packets = 15.
then each transmit virtqueue of a device will operate as follows:
The device will count packets sent on each virtqueue until it accumulates 15, or until 10 microseconds elapsed since the first one was sent.
If the notifications are not suppressed by the driver, the device will send an used buffer notification, otherwise, the device will not send an used buffer notification as long as the notifications are suppressed.
5.1.6.5.9.4 Notifications When Coalescing Parameters Change

When the coalescing parameters of a device change, the device needs to check if the new notification conditions are met and send a used buffer notification if so.
For example, max_packets = 15 for a device with a single transmit virtqueue: if the device sends 10 packets and afterwards receives a VIRTIO_NET_CTRL_NOTF_COAL_TX_SET command with max_packets = 8, then the notification condition is immediately considered to be met; the device needs to immediately send a used buffer notification, if the notifications are not suppressed by the driver.
5.1.6.5.9.5 Driver Requirements: Notifications Coalescing

The driver MUST set vq_index to the virtqueue index of an enabled transmit or receive virtqueue.
The driver MUST have negotiated the VIRTIO_NET_F_NOTF_COAL feature when issuing commands VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET.
The driver MUST have negotiated the VIRTIO_NET_F_VQ_NOTF_COAL feature when issuing commands VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET.
The driver MUST ignore the values of coalescing parameters received from the VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET command if the device responds with VIRTIO_NET_ERR.
5.1.6.5.9.6 Device Requirements: Notifications Coalescing

The device MUST ignore reserved.
The device SHOULD respond to VIRTIO_NET_CTRL_NOTF_COAL_TX_SET and VIRTIO_NET_CTRL_NOTF_COAL_RX_SET commands with VIRTIO_NET_ERR if it was not able to change the parameters.
The device MUST respond to the VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET command with VIRTIO_NET_ERR if it was not able to change the parameters.
The device MUST respond to VIRTIO_NET_CTRL_NOTF_COAL_VQ_SET and VIRTIO_NET_CTRL_NOTF_COAL_VQ_GET commands with VIRTIO_NET_ERR if the designated virtqueue is not an enabled transmit or receive virtqueue.
Upon disabling and re-enabling a transmit virtqueue, the device MUST set the coalescing parameters of the virtqueue to those configured through the VIRTIO_NET_CTRL_NOTF_COAL_TX_SET command, or, if the driver did not set any TX coalescing parameters, to 0.
Upon disabling and re-enabling a receive virtqueue, the device MUST set the coalescing parameters of the virtqueue to those configured through the VIRTIO_NET_CTRL_NOTF_COAL_RX_SET command, or, if the driver did not set any RX coalescing parameters, to 0.
The behavior of the device in response to set commands of the VIRTIO_NET_CTRL_NOTF_COAL class is best-effort: the device MAY generate notifications more or less frequently than specified.
A device SHOULD NOT send used buffer notifications to the driver if the notifications are suppressed, even if the notification conditions are met.
Upon reset, a device MUST initialize all coalescing parameters to 0.
5.1.6.6 Legacy Interface: Framing Requirements

When using legacy interfaces, transitional drivers which have not negotiated VIRTIO_F_ANY_LAYOUT MUST use a single descriptor for the struct virtio_net_hdr on both transmit and receive, with the network data in the following descriptors.
Additionally, when using the control virtqueue (see 5.1.6.5) , transitional drivers which have not negotiated VIRTIO_F_ANY_LAYOUT MUST:
for all commands, use a single 2-byte descriptor including the first two fields: class and command
for all commands except VIRTIO_NET_CTRL_MAC_TABLE_SET use a single descriptor including command-specific-data with no padding.
for the VIRTIO_NET_CTRL_MAC_TABLE_SET command use exactly two descriptors including command-specific-data with no padding: the first of these descriptors MUST include the virtio_net_ctrl_mac table structure for the unicast addresses with no padding, the second of these descriptors MUST include the virtio_net_ctrl_mac table structure for the multicast addresses with no padding.
for all commands, use a single 1-byte descriptor for the ack field
See 2.7.4.
